* C++基础问题：

    - 语言基础

        - struct 结构体大小[注意对齐]：
            - example01.cpp
            - struct整体大小是最宽类型成员的整数倍

        - union联合体[共享内存]
            - 大小等于成员中宽度最长的成员大小

        - enum 
            - 与成员类型相关

        - sizeof() 运算符

        - 内存对齐:
            - 原因： 提高效率
            - eg :

                 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
                 未对齐： 假如某int数据是从1-4，则首先读取0-3，去掉0，然后读取4-7，去掉5，6，7，这样访问一个数据就读取了2次，最后还需要1-3与4合并，等操作
                 对齐： 直接从去0-3或4-7既可一次把数据读取，无需合并

            - 现代计算机内存空间一般都是安装byte划分，从理论上来说，对任何类型变量的访问可以从任何位置开始，但实际上OS对数据在内存中存放位置有所限制，要求首地址必须是某个数k[内存存取粒度]（4|8)的倍数，这就是内存对齐。

        - 指针：
            - example03.cpp
            - 概念： 是一个变量，用于存储内存地址
            + 野指针：指向不可用的内存地址的指针[野指针不是NULL指针]，是指向"垃圾” 内存的指针
                - example02.cpp
                - 原因1： 指针没有初始化
                - 原因2： 指针被free/delete 后没有置空[NULL|nullptr],z只是把指针指向的内存释放，但没有把指针自身释放
                - 原因3： 指针操作超越了变量的作用范围
        - 空指针 ： NULL | nullptr
            - 空指针是一个特殊的指针值，也是唯一一个对任何指针类型都合法的指针值
        - pointer | const 
            + 常量指针[read-only] ： int const *p | const int *p
                - 指针p可变，可以指向其他内存地址
                - 指针p指向的内存地址中的数据不能变[不能通过p修改其内存中的值]，比如 *p = 2 ❌， p = &b, ✔

            + 指针常量 ： int * const p 
                - 指针是一个常量，指针不能表[指针p只能指向该地址]
                - 指针指向的内存地址的数据是可以表的 *p = 2 ✔ , p = &b ❌

            + 指向常量的常量指针：const int * const p 
                - 指向常量的指针是一个常量，且指向的对象也是一个常量
                - 指针不能改，只能指向该地址      *p = 2 ❌ , p = &b ❌
                - 指针指向的内存地址中的数据不能改 *p = 2 ❌ , p = &b ❌

        - 内存泄漏：
            - 用动态存储分配函数动态开辟的空间，在使用完毕后未释放，结果导致一直占据该内存单元。直到程序结束。即所谓内存泄漏[内存泄漏是指堆内存的泄漏]

        + 智能指针:
            - **智能指针是行为类似指针的类对象**
            - **所有智能指针都有一个explicit构造函数**
            - 智能指针几乎都是模板类
            - c++的智能指针是包含了重载运算符的类，其行为类似常规指针，但能够及时妥善销毁和动态分配内存，有明确的生命周期的类
            - 智能指针重载了**解引用运算符(*)和成员选择运算符(->)**,使得行为类似常规指针
            - 智能指针超过作用域[过期]后，其析构函数会自动delete释放内存
            + 智能指针的内存资源分配策略：
                - 深复制 ： 每个智能指针都保存一个管理它的对象的完整副本
                - 写时复制[copy-on-write|COW]
                - 引用计数： 记录对象的用户数量的机制
                    - 复制时，reference-counting + 1
                    - 删除时，reference-counting - 1
                    - 当引用计数为0时，则释放内存

                    - **使用引用计数会存在一个问题： A对象存储指向B的指针，B对象存储指向A的指针，则这两个对象永远都不会释放**
                        - A <-----> B
                        + 解决方法： **弱引用**

                - 引用连接:

                - 破坏复制: 智能指针在被复制时，将对象的所有权交出，并重置原来的指针
                    - 可以确保任何时候都只有一个指针指向对象
                    - auto_ptr就是基于破坏复制的策略[auto_ptr已被C++11摒弃]

            + C++11之后的三大智能指针：
                + unique_ptr:
                    - **内存策略**：所有权[owership]: 任何时刻只能有一个智能指针拥有它
                    - 不允许复制和赋值： 复制构造函数和复制运算符被声明为**私有**，因此不能复制和赋值
                + shared_ptr:
                    - **内存策略**： 基于引用计数[reference-counting]
                    - 见myShared_ptr.cpp
                    - 可能出现一个环形引用，导致引用计数永远不会减为0,因此为解决这个引入了weak_ptr
                    - 多个对象指向同一个对象
                    - 复制时[copy-constructor]， reference-counting  + 1
                    - 赋值时[operator=]， 原来对象的reference-counting  - 1。 后来指向的对象的 引用对象的 reference-counting + 1

                + weak_ptr:

        + 左值与右值：
            - 左值[left-value]： 可以取地址，有名字的[不能被移动]
                - 左值一定在内存中[只有在内存中才可以取地址]
            - 右值[right-value]： **是表达式中间结果/函数返回值/临时值**, 不能其地址，没有名字的值[将亡值|纯右值]
                - 右值可能在内存或寄存器中

            - **左值可以转为右值，但是右值不能转为左值**

        - 引用**必须显式的初始化**，不允许空引用[null-reference] 且一旦绑定了初始值，就 不能重新绑定 到其他值上了

        + 左值引用[&]与右值引用[&&]：
            - 左值引用[lvalue-reference]：用 & 符号引用 左值[但不能引用右值]
                - 左值引用是具名变量的别名
            + 右值引用[rvalue-reference]：**用 && 符号引用 右值（也可以移动左值)[通过std::move()将左值转为右值]**
                - 右值引用创建对右值的引用，调用结束后，右值引用就会被销毁
                - 右值引用不具名[匿名]变量的别名
        
        + Move semantics移动语义：
        + Perfect forwarding完美转发：
            std::forward()

        + std::move()| std::forward()实现及原理
            - 通用引用和完美转发

        + **移动语义[move-semantics]**： C++11支持移动语义
            = 右值对象一般是临时对象，在移动时，对象包含的资源 不需要先拷贝再删除，只需要直接 从旧对象移动到新对象[避免先拷贝再释放资源]。
            - 概念： 实际的文件保留在原来的地方，只是修改记录[避免移动原始数据，只是修改了记录]
            - 移动语义主要解决std::unique_ptr所有权转移的问题，同时可以避免先拷贝再释放资源的问题。
            - 右值引用配合移动语义，实现移动构造函数和移动赋值函数
            

            + 编译器怎么知道什么时候复制，什么时候不复制？
                - 左值引用和右值引用来解决
                + 右值引用支持移动语义
            - 复制构造： 可执行深复制
            - 移动构造： 只是修改记录[将所有权交给新对象]**移动构造可能修改实惨，因此右值引用不应该是const**

            - 移动语义的实现： 右值引用 + 移动构造函数
            - 左值引用初始化对象时，将使用复制构造函数
            - 右值引用初始化对象时，将使用移动构造函数
            [右值引用|移动语义|拷贝省略|通用引用|完美转发]
        + class的特殊成员：
            - **默认构造， 复制构造， 复制赋值运算符， 析构函数， 移动构造函数， 移动复制构造函数[编译器默认自动提供]**
            ```
            class A()
            {
                A()                                         //默认构造函数
                A(const A& a);                              //默认复制构造
                A(A&& a);                                   //默认移动构造
                A& operator=(const A& a) const;             //默认复制赋值
                A& operator=(A&& a);                        //默认移动赋值
                ~A()                                        //默认析构函数
            };
            ```

        - new/delete | mallocl|free
        - const关键字

        - typename 

        - RAII 
        - lamada



    - C++ 内存布局
        + 堆
        + 栈
    - class 与 strcut 区别
    - class相关问题：
        - 空类大小
        - 含成员变量(函数)的大小
        - 含静态成员(函数)的大小
        - const 与 static
        - this指针

    - 重载|重写

    - 多态与虚函数：
        + 多态：
            - 静态联编
            - 动态联编

        

        + 虚函数
            - 虚函数表vpbl
            - 虚指针vptr

            + 纯虚函数 与 抽象类

    - 继承 

    - C++11新特性

        

    - STL
        + 顺序容器：
            + vector
                + 底层原理， resize和reserve方法及原理
            + deque

        + 关联容器：
            + map
            + multimap
            + unordered_map

            + set 
            + multiset
            + unordered_set

        + 容器适配器：
